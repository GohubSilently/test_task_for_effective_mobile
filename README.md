# Тестовое задание для Effective Mobile

---

## Оглавление
- [Схема управления ограничениями доступа (RBAC + Session)](#схема-управления-ограничениями-доступа-rbac--session)
- [Запуск проекта](#запуск-проекта)
- [P.S.](#ps-как-я-пришел-к-данной-реализации-если-интересно-почитать)

---

# Схема управления ограничениями доступа (RBAC + Session)

Документ описывает архитектуру аутентификации и авторизации в API, основанную на сессионных токенах и ролевой модели доступа (RBAC).

## Общая архитектура

Поток запроса выглядит так:
1. Клиент отправляет HTTP‑запрос с заголовком `Authorization: Session <token>`
2. `SessionAuthentication` проверяет токен и определяет пользователя
3. DRF сохраняет пользователя в `request.user`
4. `CustomPermission` проверяет:
   1. Аутентификацию пользователся
   2. Какой HTTP-метод(action model) выполняется (GET / POST / PUT / DELETE и т.д.)
   3. Проверяет роль пользователя на право выполнения этого действие над ресурсом
5. Запрос либо проходит, либо отклоняется с ошибкой 401() / 403

## Аутентификация

Используется кастомная аутентификация на основе сессионного токена.
Источник истины — таблица `Session`
'session_token' — уникальный токен (uuid)
`user - — связанный пользователь

### Правила

1. Отсутствие заголовка `Authorization` = 401
2. Неверный формат заголовка = 401
3. Несуществующий токен = 401
4. Неактивный пользователь (`is_active=False`) = 401

### Результат

`request.user` содержит пользователя
`request.auth` содержит объект сессии

## Авторизация (RBAC)

Используется ролевая модель доступа (Role‑Based Access Control).

### Основные сущности

1. **Role** — роль пользователя (admin, moderator, user и т.д.)
2. **Resource** — логический ресурс API (например: `users`, `projects`, `donations`)
3. **Action** — действие над ресурсом (`get`, `post`, `put`, `patch`, `delete`)
4. **Permission** — правило доступа: `role + resource + action`

### Принцип

Все разрешения хранятся в базе данных. Код не содержит жёстко заданных прав.
Исключение:
Роль `admin` имеет полный доступ ко всем ресурсам и действиям

## Проверка прав доступа

### Функция `check_permissions`

Алгоритм:

1. Если роль пользователя `admin` = доступ разрешён
2. Проверяется существование `Resource` и `Action`
3. Проверяется наличие записи в таблице `Permission`
4. Если запись найдена = доступ разрешён

### CustomPermission

Каждый View подключает permission‑класс и указывает ресурс:

HTTP‑метод автоматически маппится на действие:
* GET - get
* POST - post
* PUT - put
* PATCH - patch
* DELETE - delete

### Ошибки

* Пользователь не аутентифицирован = 401
* Метод не поддерживается = 403
* Нет прав у роли = 403


## Запуск проекта
1. Клонируем репозиторий.
```
git clone git@github.com:GohubSilently/test_task_for_effective_mobile.git
cd test_task_for_effective_mobile
```

2. Создаем .env
```
POSTGRES_DB=postgres
POSTGRES_USER=postgres_user
POSTGRES_PASSWORD=postgress_password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432

SECRET_KEY='your_secret_key'
DEBUG=True
ALLOWED_HOSTS=localhost 127.0.0.1
```

3. Загружаем данные.
```
pip install --upgrade pip & pip install -r requirements.txt
cd app
python manage.py migrate
python manage.py load_action && python manage.py load_role && python manage.py load_resource && python manage.py load_permission
python manage.py load_user && python manage.py load_session
python manage.py runserver
```

4. Открываем документацию API - [ссылка](http://127.0.0.1:8000/api/docs/swagger/)


### P.S. Как я пришел к данной реализации. Если интересно почитать.
1. Когда я прочитал тз, я начал искать информацию, про аутентификацию и авторизацию.
Сначала прочитал, статью на Хабре, как работает 'django.contrib.auth'. - [ссылка](https://habr.com/ru/companies/otus/articles/855086/)
После этого наткнулся на видос, который длится около двух часов (спасибо за возможности ускорить видео). - [ссылка](https://www.youtube.com/watch?v=7jnJbZIvQ5s)
С помощью видео я повторил основы, и наткнулся на новые интересные алгоритмы по хешированию паролей. (bcrypt, argon2)
P.S. Почитал про них, и наткнулся на библиотеку для Python.
2. При просмотре этого видео, я уже впринципе решил для себя, что буду использовать сессии, а именно токены, не JWT.
Если честно, не вижу проблемы переделать под JWT, дело 20 минут.
Однако, с библтотекой JWT я уже работал раньше, и решил попробовать что-то новое для себя.
3. Изначально по коммитам в ветку можно понять насколько код претерпел изменения.
Честно, я дольше пытался придумать как назвать проект, чем сколько заняла его реализация.
В тз написано, рекомендация база PostgreSQL, изначально я запустил ее в Docker, так что оставил файл на всякий случай в репозитории.
